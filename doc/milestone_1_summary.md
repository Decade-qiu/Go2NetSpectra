 # Milestone 1: 核心引擎与离线分析总结

本文档旨在总结 Go2NetSpectra 项目在完成第一里程碑（MVP）后所达成的功能、采用的技术路线、核心工作流程，并梳理开发过程中的技术难点与亮点。

---

## 1. 已完成需求

我们成功实现并验证了 **里程碑 1** 的核心目标，即**具备核心数据处理能力的离线分析引擎**。具体完成的需求点如下：

*   **FR-2 (读取离线文件)**: 程序可以成功读取标准的 `.pcap` 文件。
*   **FR-3 (提取元数据)**: 能够从数据包中成功解析出五元组信息（源/目的IP、源/目的端口、协议）。
*   **FR-7 (协议解析)**: 已支持对 `Ethernet`, `IPv4/v6`, `TCP`, `UDP`, `ICMP` 等协议的解析。
*   **FR-8 (流聚合)**: 实现了基于五元组任意组合的流聚合与生命周期管理（通过周期性快照）。
*   **FR-9 (核心指标)**: 已构建了流聚合的基础，能够计算流的**包数**、**字节数**和**持续时间**，为后续实现高级指标（如 HLL, Count-Min Sketch）打下了基础。
*   **NFR-1 (性能)**: 通过对千万级数据包的压力测试，验证了核心引擎的处理能力超过 **500,000 PPS**，达到了预设的性能指标。

## 2. 技术路线总结

为实现上述需求，我们选择并验证了以下技术路线：

*   **核心语言**: **Go**。利用其出色的并发性能和简洁的语法，构建高性能数据处理管道。
*   **核心依赖库**:
    *   `github.com/google/gopacket`: 用于解码数据包协议层，是数据解析的核心。
    *   `gopkg.in/yaml.v3`: 用于解析 `config.yaml` 配置文件，实现配置驱动。
*   **核心设计模式**:
    *   **并发模型**: 采用了“生产者-消费者”模式，构建了 **多级并发流水线 (Staged Pipeline)**，将读取、解析、聚合等步骤解耦。
    *   **聚合性能**: 聚合器内部采用了**分片并发（Sharding）**的设计，将一个大的 `map` 拆分为256个小 `map`，每个 `map` 拥有独立的锁，极大地降低了高并发下的锁竞争，是实现高性能聚合的关键。
    *   **配置化设计**: 核心的流聚合维度没有被硬编码在代码中，而是通过 `config.yaml` 文件动态加载。这使得框架的扩展性极强，未来增加新的聚合维度无需修改核心代码。
    *   **数据持久化**: 采用了**周期性快照 (Periodic Snapshot)** 机制。通过“指针交换”的原子操作，实现了在不中断数据处理的前提下，无缝地将内存中的流数据转储(dump)出来，为后续写入磁盘做准备。
    *   **数据序列化**: 使用 Go 原生的 `encoding/gob` 对内存中的流 `map` 进行序列化，以便高效地写入文件。

## 3. 数据包处理流程

一个数据包从输入到最终被统计的完整生命周期如下：

1.  **启动**: `ns-cli` 程序启动，加载 `configs/config.yaml` 文件。
2.  **初始化**: `FlowAggregator` 根据配置，创建出6个默认的 `KeyedAggregator`（分别对应源IP、目的IP等6个维度）。同时，`snapshot.Writer` 被创建。
3.  **引擎启动**: `FlowAggregator` 启动其内部的**工作池（Worker Pool）**和**周期性快照goroutine**。
4.  **读取与解析**: `pcap.Reader` 以**串行**方式（经测试，此方式性能最佳）读取 pcap 文件，调用 `protocol.ParsePacket` 解析出 `PacketInfo`（包含五元组）。
5.  **分发**: `PacketInfo` 被送入 `FlowAggregator` 的 `InputChannel`。
6.  **并行聚合**: 工作池中的一个 worker goroutine 从 `InputChannel` 中获取 `PacketInfo`，并将其**同时分发**给所有6个 `KeyedAggregator`。
7.  **分片处理**: 每个 `KeyedAggregator` 内部，会根据自己的聚合规则（例如，仅使用 `SrcIP`）为该数据包生成一个流 Key。通过对此 Key 进行哈希，数据包被路由到 256 个分片中的一个，并仅对该分片加锁，然后更新流的统计信息（包数、字节数等）。
8.  **周期性快照**: `snapshotter` goroutine 根据配置的周期（例如30秒）被唤醒。
9.  **无缝交换**: `snapshotter` 命令所有 `KeyedAggregator` 执行快照。每个聚合器内部的所有分片会**原子性地**将当前的流数据 map 替换为一个新的空 map，并返回旧 map 的引用。此过程极快，保证了业务不中断。
10. **导出与存储**: 旧的流数据 map（即“快照”）被打包成 `SnapshotData`，发送到 `OutputChannel`，并最终由 `snapshot.Writer` 负责创建时间戳目录，将数据序列化后写入磁盘。

## 4. 技术难点与亮点

*   **难点**:
    1.  **并发Bug定位**: 在开发过程中，我们遇到了经典的 `panic: send on closed channel` 问题。通过分析，我们定位到这是由于对并发channel的关闭时机不当导致的，最终通过明确channel所有权和使用 `sync.WaitGroup` 保证goroutine生命周期而解决。
    2.  **性能调优的非直觉性**: 我们通过实验发现，“为每个包创建一个goroutine”的过度并发模式，其性能反而不如简单的串行解析。这个发现非常有价值，它证明了任何性能优化都必须基于实际的测量数据，而不是凭空猜测。

*   **亮点**:
    1.  **高性能并发架构**: 最终确定的“分片并发聚合”架构，成功地将锁竞争带来的性能影响降至最低，在压力测试中表现出色，充分利用了多核CPU的能力。
    2.  **配置驱动的灵活性**: 整个引擎的核心——“如何定义流”，被抽象到了配置文件中。这使得 Go2NetSpectra 成为一个真正的“框架”，用户可以通过修改配置来增加新的数据维度，扩展性极强。
    3.  **无缝数据快照**: “指针交换”式的快照机制，保证了7x24小时不间断的数据处理能力，是生产级监控系统设计的典范。
